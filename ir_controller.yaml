esphome:
  name: ir-controller
  libraries:
    - IRremoteESP8266
  on_boot:
    priority: -100
    then:
      - lambda: |-
          //id(ac) = new IRsend(id(ir_send_pin));
          //id(ac)->begin();
          //id(irrecv) = new IRrecv(id(ir_recv_pin), id(ir_recv_buf_size), 
          //                          id(ir_recv_timeout), true);
          //id(irrecv)->setUnknownThreshold(id(ir_recv_ignore));
          //id(irrecv)->setTolerance(id(ir_recv_tolerance));
          //id(irrecv)->enableIRIn();
          if(id(reverse_switch).state) {
            id(reverse_flag) = 0xff;
          } else {
            id(reverse_flag) = 0x0;
          }

  
  # on_shutdown:
  #   priority: 700
  #   then:
  #     - lambda: |-
  #         delete id(ac);

  

web_server:
  port: 80
  version: 3
  sorting_groups:
    - id: sorting_group_switch
      name: "Switch"
      sorting_weight: 10
    - id: sorting_group_button
      name: "Button"
      sorting_weight: 20
    - id: sorting_group_extra
      name: "Extra"
      sorting_weight: 30

esp8266:
  board: esp_wroom_02

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:

ota:
  - platform: esphome
    password: "homeassistant"

wifi:
  ssid: <your SSID>
  password: <your WiFi password>

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Ir-Controller Fallback Hotspot"
    password: "homeassistant"

captive_portal:

status_led:
  pin: 15

remote_transmitter:
  - id: rc_transmitter
    pin: 13
    carrier_duty_percent: 100%
  
  - id: ac
    pin: 14
    carrier_duty_percent: 50%

remote_receiver:
  - id: irrecv
    pin: 5
    tolerance: 25%
    #unknown_threshold: 12
    idle: 50ms
    # dump: none

globals:
  - id: ac_off_time
    type: ESPTime
    restore_value: no
    initial_value: "{0}"
  - id: reverse_flag
    type: uint8_t
    restore_value: no
    initial_value: "0"
  # - id: ir_recv_timeout
  #   type: uint8_t
  #   restore_value: no
  #   initial_value: "50"
  # - id: ir_recv_ignore
  #   type: uint16_t
  #   restore_value: no
  #   initial_value: "12"
  # - id: ir_recv_tolerance
  #   type: uint8_t
  #   restore_value: no
  #   initial_value: "25"
  # - id: irrecv
  #   type: IRrecv *
  #   restore_value: no
  #   initial_value: "NULL"

binary_sensor:
  - platform: gpio
    id: ir_dump_pin
    name: "IR dump"
    icon: "mdi:record-rec"
    pin:
      number: 4
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: 10ms
    web_server:
      sorting_weight: 12

interval:
  - interval: 100ms
    then:
      - if:
          condition:
            binary_sensor.is_on: "ir_dump_pin"  # 检查按钮是否被按下
          then:
            - remote_receiver.receive:  # 手动接收信号
                id: irrecv
            - logger.log:
                level: INFO
                format: "ir_dumpn -> value = %s addr = %d command = %d decode_type = %d"
                args: ["'{{ irrecv.received_code }}'", "'{{ irrecv.received_address }}'", "'{{ irrecv.received_command }}'", "'{{ irrecv.received_type }}'"]
  # - interval: 100ms
  #   then:
  #     - lambda: |-
  #         decode_results results;
  #         if (id(ir_dump_pin).state && id(irrecv)->decode(&results)) {
  #           if (results.overflow) ESP_LOGW("ir_dump", "Buffer is full");
  #           ESP_LOGI(, uint64ToString(results.value, HEX), results.address, results.command, results.decode_type);
  #         }

  #小区门禁
  # - interval: 500ms
  #   then:
  #     - if:
  #         condition:
  #           wifi.connected
  #         then:
  #         else:
  #           remote_transmitter.transmit_rc_switch_raw:
  #             code: '00101110100011010001000'
  #             repeat:
  #               times: 10
  #               wait_time: 0ms
  #             protocol: 
  #               #The pulse length of the protocol - how many microseconds one pulse should last for.
  #               pulse_length: 260

button:
  - platform: template
    name: Rotate Right
    id: clockwise
    # friendly_name: 顺时针转动
    # Optional variables:
    icon: "mdi:rotate-right"
    web_server:
      sorting_group_id: sorting_group_button
      sorting_weight: 0
    on_press:
      - lambda: |-
          if (id(ac)) {
            // id(ac)->on();
            id(ac)->sendNEC(0xFF807FUL);
          }
  - platform: template
    name: Rotate Left
    id: anticlockwise
    # friendly_name : 逆时针转动
    # Optional variables:
    icon: "mdi:rotate-left"
    web_server:
      sorting_weight: 1
      sorting_group_id: sorting_group_button
    on_press:
      - lambda: |-
          if (id(ac)) {
            // id(ac)->on();
            id(ac)->sendNEC(0xFF906FUL);
          }

  - platform: template
    name: Send RC1
    id: send_rc1
    # friendly_name : 射频开关1
    # Optional variables:
    icon: "mdi:radio-tower"
    web_server:
      sorting_weight: 2
      sorting_group_id: sorting_group_button
    on_press:
      - remote_transmitter.transmit_rc_switch_raw:
          code: '000111011100110110100100'
          repeat:
            times: 10
            wait_time: 0ms
          protocol: 
            #The pulse length of the protocol - how many microseconds one pulse should last for.
            pulse_length: 320

  - platform: template
    name: Send RC2
    id: send_rc2
    # friendly_name : 射频开关2
    # Optional variables:
    icon: "mdi:radio-tower"
    web_server:
      sorting_weight: 2
      sorting_group_id: sorting_group_button
    on_press:
      - remote_transmitter.transmit_rc_switch_raw:
          code: '011111000101101001100100'
          repeat:
            times: 10
            wait_time: 0ms
          protocol: 
            #The pulse length of the protocol - how many microseconds one pulse should last for.
            pulse_length: 100

switch:
  - platform: template
    id: switch1
    name: "Switch"
    icon: "mdi:lightbulb"
    web_server:
      sorting_weight: 2
      sorting_group_id: sorting_group_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          if (id(ac)) {
            // id(ac)->on();
            id(ac)->sendNEC(0xf + ((0xFF807UL + id(reverse_flag)) << 4));
          }
          ESP_LOGD("switch", "[%x] switch on", 0xf + ((0xFF807UL + id(reverse_flag)) << 4));
    turn_off_action:
      - lambda: |-
          if (id(ac)) {
            id(ac)->sendNEC(0xf + ((0xFF906UL - id(reverse_flag)) << 4));
          }
          ESP_LOGD("switch", "[%x] switch off", 0xf + ((0xFF906UL - id(reverse_flag)) << 4));

  - platform: template
    id: reverse_switch
    name: "Reverse Switch"
    icon: "mdi:screen-rotation-alt"
    web_server:
      sorting_weight: 3
      sorting_group_id: sorting_group_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          id(reverse_flag) = 0xff;
    turn_off_action:
      - lambda: |-
          id(reverse_flag) = 0x0;

time:
  - platform: sntp
    id: sntp_time
    timezone: Asia/Shanghai
    servers:
      - ntp.ntsc.ac.cn
      - ntp.aliyun.com
      - time.windows.com
    on_time:
      - seconds: 0
        minutes: /1
        then:
          lambda: |-
            if (id(ac) && id(ac_off_time).is_valid() &&
                id(sntp_time).now() >= id(ac_off_time)) {
              if (id(switch1).state) {
                id(switch1).turn_off();
                ESP_LOGI("sntp_time", "[%s] Switch off", 
                  id(sntp_time).now().strftime("%m-%d %H:%M:%S").c_str());
              }
              auto call = id(ac_timed_off).make_call();
              call.set_time("00:00:00");
              call.perform();
            }

datetime:
  - platform: template
    id: ac_timed_off
    name: "Timed off"
    icon: "mdi:calendar-alert"
    type: time
    initial_value: "00:00:00"
    web_server:
      sorting_weight: 1
      sorting_group_id: sorting_group_extra
    optimistic: yes
    disabled_by_default: true
    on_value:
      then:
        - lambda: |-
            ESPTime time_set = id(ac_timed_off).state_as_esptime();
            if (id(sntp_time).now().is_valid()) {
              if (time_set.hour != 0 || time_set.minute != 0) {
                id(ac_off_time) = id(sntp_time).now();
                id(ac_off_time).hour += time_set.hour;
                id(ac_off_time).minute += time_set.minute;
                id(ac_off_time).second = 0;
                if (id(ac_off_time).minute > 59) {
                  id(ac_off_time).hour += 1;
                  id(ac_off_time).minute -= 59;
                }
                if (id(ac_off_time).hour > 23) {
                  id(ac_off_time).day_of_month += 1;
                  id(ac_off_time).hour -= 23;
                }
                id(ac_off_time).recalc_timestamp_local();
                ESP_LOGI("ac_timed_off", "[%s] Turn off at %s", 
                  id(sntp_time).now().strftime("%m-%d %H:%M:%S").c_str(),
                  id(ac_off_time).strftime("%m-%d %H:%M:%S").c_str());
              } else {
                id(ac_off_time).year = 0;
                id(ac_off_time).month = 0;
                id(ac_off_time).day_of_month = 0;
                id(ac_off_time).hour = 0;
                id(ac_off_time).minute = 0;
                id(ac_off_time).second = 0;
                id(ac_off_time).recalc_timestamp_local();
              }
            } else
              ESP_LOGW("ac_timed_off", "SNTP not finished yet.");
